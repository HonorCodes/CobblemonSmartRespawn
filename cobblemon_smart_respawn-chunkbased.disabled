// Cobblemon Smart Respawn (Rhino-safe)
// Minecraft 1.21.1 + NeoForge + KubeJS 2101.x
// Avoids modern JS (no optional chaining/nullish/destructuring), no java.nio, no Maps/Sets.

var CSR = typeof global !== 'undefined' && global.CSR ? global.CSR : {};
if (!CSR) CSR = {};
if (CSR.graceSeconds == null) CSR.graceSeconds = 30;
if (CSR.removeCount == null) CSR.removeCount = 2;
if (CSR.minAllowedPerChunk == null) CSR.minAllowedPerChunk = 1;
if (CSR.perChunkOverride == null) CSR.perChunkOverride = null;
if (CSR.debug == null) CSR.debug = true;

// Species protected (legendary + paradox + etc) — based on your kill command
var PROTECTED_SPECIES = {};
(function(){
  var list = [
    "cobblemon:articuno","cobblemon:zapdos","cobblemon:moltres","cobblemon:mew","cobblemon:mewtwo",
    "cobblemon:raikou","cobblemon:entei","cobblemon:suicune","cobblemon:lugia","cobblemon:hooh",
    "cobblemon:celebi","cobblemon:regirock","cobblemon:regice","cobblemon:registeel","cobblemon:latias",
    "cobblemon:latios","cobblemon:kyogre","cobblemon:groudon","cobblemon:rayquaza","cobblemon:jirachi",
    "cobblemon:deoxys","cobblemon:uxie","cobblemon:mesprit","cobblemon:azelf","cobblemon:dialga",
    "cobblemon:palkia","cobblemon:heatran","cobblemon:regigigas","cobblemon:giratina","cobblemon:cresselia",
    "cobblemon:phione","cobblemon:manaphy","cobblemon:darkrai","cobblemon:shaymin","cobblemon:arceus",
    "cobblemon:victini","cobblemon:cobalion","cobblemon:terrakion","cobblemon:virizion","cobblemon:tornadus",
    "cobblemon:thundurus","cobblemon:landorus","cobblemon:reshiram","cobblemon:zekrom","cobblemon:kyurem",
    "cobblemon:keldeo","cobblemon:meloetta","cobblemon:xerneas","cobblemon:yveltal","cobblemon:zygarde",
    "cobblemon:diancie","cobblemon:hoopa","cobblemon:volcanion","cobblemon:tapukoko","cobblemon:tapulele",
    "cobblemon:tapubulu","cobblemon:tapufini","cobblemon:typenull","cobblemon:silvally","cobblemon:cosmog",
    "cobblemon:necrozma","cobblemon:magearna","cobblemon:marshadow","cobblemon:zeraora","cobblemon:meltan",
    "cobblemon:melmetal","cobblemon:zacian","cobblemon:zamazenta","cobblemon:eternatus","cobblemon:kubfu",
    "cobblemon:urshifu","cobblemon:zarude","cobblemon:regieleki","cobblemon:regidrago","cobblemon:glastrier",
    "cobblemon:spectrier","cobblemon:calyrex","cobblemon:enamorus","cobblemon:wochien","cobblemon:chienpao",
    "cobblemon:tinglu","cobblemon:chiyu","cobblemon:koraidon","cobblemon:miraidon","cobblemon:okidogi",
    "cobblemon:munkidori","cobblemon:fezandipiti","cobblemon:ogerpon","cobblemon:terapagos","cobblemon:pecharunt",
    "cobblemon:nihilego","cobblemon:buzzwole","cobblemon:pheromosa","cobblemon:xurkitree","cobblemon:celesteela",
    "cobblemon:kartana","cobblemon:guzzlord","cobblemon:poipole","cobblemon:naganadel","cobblemon:stakataka",
    "cobblemon:blacephalon","cobblemon:greattusk","cobblemon:screamtail","cobblemon:brutebonnet","cobblemon:fluttermane",
    "cobblemon:slitherwing","cobblemon:sandyshocks","cobblemon:irontreads","cobblemon:ironbundle","cobblemon:ironhands",
    "cobblemon:ironjugulis","cobblemon:ironmoth","cobblemon:ironthorns","cobblemon:roaringmoon","cobblemon:ironvaliant",
    "cobblemon:walkingwake","cobblemon:ironleaves","cobblemon:gougingfire","cobblemon:ragingbolt","cobblemon:ironboulder",
    "cobblemon:ironcrown"
  ];
  for (var i = 0; i < list.length; i++) PROTECTED_SPECIES[list[i]] = true;
})();

function readCobblemonConfig() {
  // Returns { perChunkCap:int, sliceDistance:int }
  var perChunk = 1.2; // default
  var slice = 96;     // default
  try {
    var cfg = JsonIO.read('config/cobblemon/main.json');
    if (cfg) {
      if (typeof cfg.pokemonPerChunk === 'number') perChunk = cfg.pokemonPerChunk;
      if (cfg.maximumSliceDistanceFromPlayer != null) slice = cfg.maximumSliceDistanceFromPlayer;
    }
  } catch (err) {
    console.warn('[CSR] Could not read config/cobblemon/main.json: ' + err);
  }
  var cap = CSR.perChunkOverride != null ? CSR.perChunkOverride : perChunk;
  if (cap < CSR.minAllowedPerChunk) cap = CSR.minAllowedPerChunk;
  return { perChunkCap: Math.ceil(cap), sliceDistance: Math.max(16, Math.floor(slice)) };
}

function chunkKey(dim, cx, cz) { return dim + '|' + cx + '|' + cz; }

var pending = {}; // key -> { runAtMs:number, dim:string, cx:int, cz:int }
var dirty = {};   // set of keys that had spawns recently

function schedule(dim, cx, cz) {
  var key = chunkKey(dim, cx, cz);
  if (!pending[key]) {
    pending[key] = { runAtMs: (Date.now() + CSR.graceSeconds * 1000), dim: dim, cx: cx, cz: cz };
    if (CSR.debug) console.info('[CSR] Scheduled check for ' + key + ' in ' + CSR.graceSeconds + 's');
  }
  dirty[key] = true;
}

function isWildPokemon(e) {
  if (!e || String(e.type) !== 'cobblemon:pokemon') return false;
  try {
    var nbt = e.getEntityData();
    var p = nbt ? nbt.Pokemon : null;
    if (!p) return false;
    var trainer = p.PokemonOriginalTrainerType;
    return (trainer == null || String(trainer) === 'NONE'); // treat null as wild
  } catch (err) {
    return false;
  }
}

function isProtected(e) {
  try {
    var nbt = e.getEntityData();
    if (!nbt) return false;

    // Keep NoAI mobs
    if (nbt.NoAI === 1 || nbt.NoAI === true) return true;

    // Nametagged
    if (nbt.CustomName != null) return true;

    var p = nbt.Pokemon;
    if (!p) return false;

    // Shiny
    if (p.Shiny === 1 || p.Shiny === true) return true;

    // Tamed / caught
    var tt = p.PokemonOriginalTrainerType;
    if (tt != null && String(tt) !== 'NONE') return true;

    // Legendary list
    var sp = p.Species != null ? String(p.Species) : '';
    if (PROTECTED_SPECIES[sp]) return true;
  } catch (err) {}
  return false;
}

function doCheck(server, entry) {
  var cfg = readCobblemonConfig();
  var level = server.getLevel(entry.dim);
  if (!level) return;

  // Collect all cobblemon:pokemon in this chunk
  var ents = level.getEntities();
  var inChunk = [];
  var cx = entry.cx, cz = entry.cz;

  for (var i = 0; i < ents.length; i++) {
    var e = ents[i];
    if (String(e.type) !== 'cobblemon:pokemon') continue;
    var ecx = Math.floor(e.x / 16);
    var ecz = Math.floor(e.z / 16);
    if (ecx !== cx || ecz !== cz) continue;

    // within slice distance of a player (safety so we don't pop in front of players)
    var tooClose = false;
    var players = level.players;
    for (var pi = 0; pi < players.length; pi++) {
      var p = players[pi];
      var dx = e.x - p.x;
      var dz = e.z - p.z;
      var d2 = dx*dx + dz*dz;
      if (d2 <= (cfg.sliceDistance * cfg.sliceDistance)) { tooClose = true; break; }
    }
    if (tooClose) continue;

    inChunk.push(e);
  }

  // Count wild and pick cull candidates
  var wild = [];
  var candidates = [];
  for (var j = 0; j < inChunk.length; j++) {
    var ent = inChunk[j];
    if (isWildPokemon(ent)) {
      wild.push(ent);
      if (!isProtected(ent)) candidates.push(ent);
    }
  }

  var allowed = cfg.perChunkCap;
  if (wild.length > allowed && candidates.length > 0) {
    // sort by age (oldest first)
    candidates.sort(function(a, b) {
      var aa = (a.age != null ? a.age : (a.ticksExisted != null ? a.ticksExisted : 0));
      var bb = (b.age != null ? b.age : (b.ticksExisted != null ? b.ticksExisted : 0));
      return bb - aa;
    });
    var n = Math.min(CSR.removeCount, candidates.length);
    for (var k = 0; k < n; k++) {
      var victim = candidates[k];
      var name = String(victim.displayName != null ? victim.displayName : victim.type);
      console.info('[CSR] Culling ' + name + ' at ' + Math.floor(victim.x) + ',' + Math.floor(victim.y) + ',' + Math.floor(victim.z) +
                   ' in ' + entry.dim + ' (wild in-chunk=' + wild.length + ' > cap=' + allowed + ')');
      victim.discard(); // remove
    }
  }

  if (CSR.debug) {
    console.info('[CSR] Checked ' + entry.dim + ' chunk ' + cx + ',' + cz + ' — wild=' + wild.length + ', allowed=' + allowed + ', candidates=' + candidates.length);
  }
}

// Mark chunk when Pokémon spawn
EntityEvents.spawned(function(event){
  var e = event.entity;
  if (!e || String(e.type) !== 'cobblemon:pokemon') return;
  var dim = String(e.level.dimension);
  var cx = Math.floor(e.x / 16);
  var cz = Math.floor(e.z / 16);
  schedule(dim, cx, cz);
});

// Run checks when timers elapse
ServerEvents.tick(function(event){
  var server = event.server;
  var now = Date.now();
  var toRun = [];
  for (var key in pending) {
    if (pending.hasOwnProperty(key)) {
      var p = pending[key];
      if (p.runAtMs <= now) {
        toRun.push(p);
        delete pending[key];
      }
    }
  }
  for (var i = 0; i < toRun.length; i++) {
    doCheck(server, toRun[i]);
  }
});
